<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document Conversion Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Link to the main stylesheet -->
  <link rel="stylesheet" href="styles.css">

  <!-- Font Awesome for copy icons (optional) -->
  <link 
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <!-- Include Marked.js for Markdown rendering in JS playground output -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <!-- Include DOMPurify for sanitization -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/2.4.0/purify.min.js"></script>

  <style>
    /* Container for the entire page */
    .page-container {
      display: flex;
      flex-direction: column;
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 10px;
    }
    /* Header style */
    .header {
      margin-bottom: 20px;
    }
    /* Form container for options and file upload */
    .options-form {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      border: 1px solid #eee;
      padding: 20px;
      border-radius: 10px;
    }
    /* Each option item style */
    .option-item {
      display: flex;
      flex-direction: column;
      width: 220px;
    }
    .option-item label {
      font-weight: 600;
      margin-bottom: 5px;
    }
    .option-item input,
    .option-item select,
    .option-item textarea {
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .option-item textarea {
      resize: vertical;
    }
    /* Container for the Convert button */
    .convert-button-container {
      margin-top: 20px;
      text-align: center;
    }
    .convert-button {
      padding: 10px 25px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background-color: #d0f0c0;
    }
    .convert-button:hover {
      background-color: #b0e0a0;
    }
    /* Progress box style */
    .progress-box {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #eaeaea;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    /* Final result container style */
    .result-container {
      margin-top: 20px;
      display: none; /* hidden until result is ready */
    }
    .json-result {
      width: 100%;
      height: 300px;
      overflow: auto;
      background-color: #fafafa;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      white-space: pre;
      font-family: monospace;
    }
    .result-buttons {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }
    /* Indicator for attached file */
    #fileAttachedIndicator {
      margin-top: 5px;
      font-size: 14px;
      color: #666;
    }
  </style>
</head>
<body>

<div class="page-container">

  <!-- Main page title -->
  <h1 class="header">Document Conversion Playground</h1>

  <!-- Options and file upload form -->
  <div class="options-form">

    <!-- Model selection drop-down -->
    <div class="option-item">
      <label for="modelSelect">Model</label>
      <select id="modelSelect">
        <option value="">Loading models...</option>
      </select>
    </div>

    <!-- Minimum OCR quality field -->
    <div class="option-item">
      <label for="ocrThresholdInput">Minimum OCR quality</label>
      <input type="number" id="ocrThresholdInput" min="0" max="1" step="0.05" value="1.0">
    </div>

    <!-- Page numbering option -->
    <div class="option-item">
      <label for="pageNumberingSelect">Page Numbering</label>
      <select id="pageNumberingSelect">
        <option value="true" selected>Enable</option>
        <option value="false">Disable</option>
      </select>
    </div>

    <!-- Detect boundaries option -->
    <div class="option-item">
      <label for="detectBoundariesSelect">Detect Boundaries</label>
      <select id="detectBoundariesSelect">
        <option value="false" selected>No</option>
        <option value="true">Yes</option>
      </select>
    </div>

    <!-- Generate description option -->
    <div class="option-item">
      <label for="describeSelect">Generate description?</label>
      <select id="describeSelect">
        <option value="true" selected>Yes</option>
        <option value="false">No</option>
      </select>
    </div>

    <!-- Generate tags? (JSON) field with example -->
    <div class="option-item">
      <label for="tagsInput">Generate tags? (JSON)</label>
      <textarea id="tagsInput" rows="3" placeholder='{"pricing": "info on pricing", "genetics": "info relevant to genetics"}'></textarea>
    </div>

    <!-- Page description field -->
    <div class="option-item">
      <label for="descriptionInput">Page Description</label>
      <textarea id="descriptionInput" rows="3" placeholder="High-level doc description"></textarea>
    </div>

    <!-- Intent field -->
    <div class="option-item">
      <label for="intentInput">Intent</label>
      <textarea id="intentInput" rows="3" placeholder="What do you plan to do with the doc?"></textarea>
    </div>

    <!-- Graphic instructions field -->
    <div class="option-item">
      <label for="graphicInstructionsInput">Graphic Inst.</label>
      <textarea id="graphicInstructionsInput" rows="3" placeholder="Extra instructions for charts/figures"></textarea>
    </div>

    <!-- File upload area (PDF) -->
    <div style="width: 100%; margin-top:10px;">
      <label style="font-weight:600; display:block; margin-bottom:5px;">File to convert (.pdf)</label>
      <div id="dropArea" class="drop-area">
        <label for="fileInput" id="fileInputLabel">Attach PDF</label>
        <input type="file" id="fileInput" accept=".pdf" />
      </div>
      <!-- Visible indicator that shows when a PDF is attached -->
      <p id="fileAttachedIndicator">No file attached yet.</p>
    </div>

    <!-- Another area for .doc.json files -->
    <div style="width: 100%; margin-top:10px;">
      <label style="font-weight:600; display:block; margin-bottom:5px;">Or load existing .doc.json</label>
      <div id="docJsonDropArea" class="drop-area">
        <label for="docJsonFileInput" id="docJsonFileLabel">Attach .doc.json</label>
        <input type="file" id="docJsonFileInput" accept=".doc.json" />
      </div>
      <p id="docJsonAttachedIndicator">No .doc.json loaded.</p>
    </div>

  </div> <!-- .options-form -->

  <!-- Convert Document button -->
  <div class="convert-button-container">
    <button class="convert-button" id="convertBtn">Convert Document</button>
  </div>

  <!-- Progress box -->
  <div class="progress-box" id="progressBox" style="display: none;">
    <div id="progressStatus"></div>
  </div>

  <!-- Final result display -->
  <div class="result-container" id="resultContainer">
    <h2>Conversion Result (JSON Document Object)</h2>
    <div class="json-result" id="jsonOutput"></div>
    <div class="result-buttons">
      <button id="copyJsonBtn"><i class="fa fa-copy"></i> Copy JSON</button>
      <button id="copyMarkdownBtn"><i class="fa fa-copy"></i> Copy as Markdown</button>
    </div>
  </div>

  <!-- Summaries container (hidden by default) -->
  <div class="result-container" id="summariesContainer" style="display: none;">
    <h2>Summaries</h2>
    <div style="display:flex; flex-wrap:wrap; gap:20px; border:1px solid #eee; padding:20px; border-radius:10px;">

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryMethodSelect"><b>Method</b></label>
        <select id="summaryMethodSelect">
          <option value="full">full</option>
          <option value="map">map</option>
          <option value="fold">fold</option>
          <option value="delta-fold">delta-fold</option>
          <!-- Add "map-merge" here -->
          <option value="map-merge">map-merge</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="chunkGroupInput"><b>Chunk Group</b></label>
        <input type="text" id="chunkGroupInput" value="pages">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="contextBeforeInput"><b>Context Chunks (Before)</b></label>
        <input type="number" id="contextBeforeInput" min="0" value="0">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="contextAfterInput"><b>Context Chunks (After)</b></label>
        <input type="number" id="contextAfterInput" min="0" value="0">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryGuidanceInput"><b>Guidance</b></label>
        <textarea id="summaryGuidanceInput" rows="3" placeholder="Any extra instructions..."></textarea>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryJsonSchemaInput"><b>JSON Schema (optional)</b></label>
        <textarea id="summaryJsonSchemaInput" rows="3" placeholder='{"type":"object","properties":{...}}'></textarea>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryModelSelect"><b>Summary Model</b></label>
        <select id="summaryModelSelect">
          <option value="">Use same model as above</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="deltaFoldMergeModeSelect"><b>delta-fold Merge Mode</b></label>
        <select id="deltaFoldMergeModeSelect">
          <option value="append" selected>append</option>
          <option value="push">push (array push)</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="initialSummaryInput"><b>Initial Summary (fold/delta-fold)</b></label>
        <textarea id="initialSummaryInput" rows="3" placeholder="Optional existing summary or array"></textarea>
      </div>

      <!-- NEW: annotation_field and annotation_field_delta inputs -->
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="annotationFieldInput"><b>Annotation Field</b></label>
        <input type="text" id="annotationFieldInput" value="summary">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="annotationFieldDeltaInput"><b>Delta Field</b></label>
        <input type="text" id="annotationFieldDeltaInput" value="summary_delta">
      </div>

      <!-- For map-merge method only: merge_summaries_guidance -->
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="mergeSummariesGuidanceInput"><b>Merge Summaries Guidance</b></label>
        <textarea id="mergeSummariesGuidanceInput" rows="3" placeholder="How to combine chunk-level summaries?"></textarea>
      </div>
    </div>

    <div style="text-align:center; margin-top:20px;">
      <button class="convert-button" id="summarizeBtn">Summarize</button>
    </div>

    <div class="progress-box" id="summaryProgressBox" style="display:none;">
      <div id="summaryProgressStatus"></div>
    </div>
  </div>

  <!-- NEW: Chunk Group Creation Container -->
  <div class="result-container" id="chunkGroupContainer" style="display:none;">
    <h2>Chunk Group Creation</h2>
    <p style="font-size:14px; color:#333;">
      This section re-chunks the existing document into a new group by calling the 
      <code>/chunkings</code> endpoint with strategy <code>merge_and_split</code>.
    </p>
    <div style="display:flex; flex-wrap:wrap; gap:20px; border:1px solid #eee; padding:20px; border-radius:10px;">
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="chunkGroupStrategySelect"><b>Strategy</b></label>
        <select id="chunkGroupStrategySelect">
          <option value="merge_and_split" selected>merge_and_split</option>
        </select>
      </div>
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="sourceChunkGroupInput"><b>Source Chunk Group</b></label>
        <input type="text" id="sourceChunkGroupInput" value="pages">
      </div>
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="chunkSizeInput"><b>Max Chunk Size (chars)</b></label>
        <input type="number" id="chunkSizeInput" value="1000">
      </div>
      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="newChunkGroupNameInput"><b>New Chunk Group Name</b></label>
        <input type="text" id="newChunkGroupNameInput" value="mergedPages">
      </div>
    </div>
    <div style="text-align:center; margin-top:20px;">
      <button class="convert-button" id="createChunkGroupBtn">Create/Add Chunk Group</button>
    </div>
    <div class="progress-box" id="chunkGroupProgressBox" style="display:none;">
      <div id="chunkGroupProgressStatus"></div>
    </div>
  </div>

  <!-- NEW: JavaScript Playground container -->
  <div class="result-container" id="jsPlaygroundContainer" style="display:none;">
    <h2>JavaScript Playground</h2>
    <p style="font-size: 14px; color: #333;">
      This lets you run custom JavaScript against the loaded <code>docObj</code>. Your function should return a 
      string of <strong>Markdown</strong> to display below.
    </p>
    <div style="display:flex; gap:10px; align-items:center; margin-bottom:10px;">
      <label for="jsSnippetSelect" style="font-weight:bold;">Templates:</label>
      <select id="jsSnippetSelect">
        <option value="">(Select a template)</option>
        <option value="extractSummary">Extract High-Level Summary</option>
        <option value="extractChunkSummaries">Extract Summaries from All Chunks</option>
      </select>
      <button class="convert-button" id="loadTemplateBtn">Load Template</button>
    </div>
    <textarea 
      id="userCodeArea" 
      style="width:100%; height:200px; font-family:monospace; font-size:14px; border:1px solid #ccc; border-radius:4px;"
    ></textarea>
    <div style="margin-top:10px; text-align:center;">
      <button class="convert-button" id="runJsBtn">Run Code</button>
    </div>
    <h3>Output:</h3>
    <div 
      id="jsPlaygroundOutput" 
      style="min-height:150px; border:1px solid #ccc; border-radius:4px; padding:10px; background-color:#fafafa; margin-top:10px;"
    ></div>
  </div>

</div> <!-- .page-container -->

<script>
  (function(){
    // ---------------------- Constants & DOM Elements ----------------------
    const CHARMONIZER_BASE = 'api/charmonizer/v1';
    const CHARMONATOR_BASE = 'api/charmonator/v1'; // for /models
    const MODELS_ENDPOINT = `${CHARMONATOR_BASE}/models`;
    const CONVERSION_BASE = `${CHARMONIZER_BASE}/conversions/documents`;
    const SUMMARIES_BASE = `${CHARMONIZER_BASE}/summaries`;
    const CHUNKINGS_BASE = `${CHARMONIZER_BASE}/chunkings`;

    // File input for PDF
    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    const fileAttachedIndicator = document.getElementById('fileAttachedIndicator');

    // .doc.json
    const docJsonFileInput = document.getElementById('docJsonFileInput');
    const docJsonDropArea = document.getElementById('docJsonDropArea');
    const docJsonAttachedIndicator = document.getElementById('docJsonAttachedIndicator');

    // Conversion options
    const modelSelect = document.getElementById('modelSelect');
    const ocrThresholdInput = document.getElementById('ocrThresholdInput');
    const pageNumberingSelect = document.getElementById('pageNumberingSelect');
    const detectBoundariesSelect = document.getElementById('detectBoundariesSelect');
    const describeSelect = document.getElementById('describeSelect');
    const tagsInput = document.getElementById('tagsInput');
    const descriptionInput = document.getElementById('descriptionInput');
    const intentInput = document.getElementById('intentInput');
    const graphicInstructionsInput = document.getElementById('graphicInstructionsInput');
    const convertBtn = document.getElementById('convertBtn');
    const progressBox = document.getElementById('progressBox');
    const progressStatus = document.getElementById('progressStatus');

    // Results
    const resultContainer = document.getElementById('resultContainer');
    const jsonOutput = document.getElementById('jsonOutput');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const copyMarkdownBtn = document.getElementById('copyMarkdownBtn');

    // Summaries
    const summariesContainer = document.getElementById('summariesContainer');
    const summaryProgressBox = document.getElementById('summaryProgressBox');
    const summaryProgressStatus = document.getElementById('summaryProgressStatus');
    const summarizeBtn = document.getElementById('summarizeBtn');
    const summaryMethodSelect = document.getElementById('summaryMethodSelect');
    const chunkGroupInput = document.getElementById('chunkGroupInput');
    const contextBeforeInput = document.getElementById('contextBeforeInput');
    const contextAfterInput = document.getElementById('contextAfterInput');
    const summaryGuidanceInput = document.getElementById('summaryGuidanceInput');
    const summaryJsonSchemaInput = document.getElementById('summaryJsonSchemaInput');
    const summaryModelSelect = document.getElementById('summaryModelSelect');
    const deltaFoldMergeModeSelect = document.getElementById('deltaFoldMergeModeSelect');
    const initialSummaryInput = document.getElementById('initialSummaryInput');
    const annotationFieldInput = document.getElementById('annotationFieldInput');
    const annotationFieldDeltaInput = document.getElementById('annotationFieldDeltaInput');
    const mergeSummariesGuidanceInput = document.getElementById('mergeSummariesGuidanceInput');

    // Chunk Group Creation
    const chunkGroupContainer = document.getElementById('chunkGroupContainer');
    const chunkGroupStrategySelect = document.getElementById('chunkGroupStrategySelect');
    const sourceChunkGroupInput = document.getElementById('sourceChunkGroupInput');
    const chunkSizeInput = document.getElementById('chunkSizeInput');
    const newChunkGroupNameInput = document.getElementById('newChunkGroupNameInput');
    const createChunkGroupBtn = document.getElementById('createChunkGroupBtn');
    const chunkGroupProgressBox = document.getElementById('chunkGroupProgressBox');
    const chunkGroupProgressStatus = document.getElementById('chunkGroupProgressStatus');

    // JavaScript Playground
    const jsPlaygroundContainer = document.getElementById('jsPlaygroundContainer');
    const jsSnippetSelect = document.getElementById('jsSnippetSelect');
    const loadTemplateBtn = document.getElementById('loadTemplateBtn');
    const userCodeArea = document.getElementById('userCodeArea');
    const runJsBtn = document.getElementById('runJsBtn');
    const jsPlaygroundOutput = document.getElementById('jsPlaygroundOutput');

    // State
    let uploadedFile = null;  // PDF
    let docJsonFile = null;   // .doc.json
    let loadedDoc = null;     // The actual JSON doc object in memory

    // ---------------------- Load models ----------------------
    async function loadModels() {
      try {
        const response = await fetch(MODELS_ENDPOINT);
        if (!response.ok) {
          throw new Error('Failed to fetch models');
        }
        const data = await response.json();
        modelSelect.innerHTML = '';
        summaryModelSelect.innerHTML = '<option value="">Use same model as above</option>';

        data.models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          option.textContent = model.name;
          option.title = model.description;
          modelSelect.appendChild(option);

          // summary
          const smOpt = document.createElement('option');
          smOpt.value = model.id;
          smOpt.textContent = model.name;
          smOpt.title = model.description;
          summaryModelSelect.appendChild(smOpt);
        });
      } catch (err) {
        console.error('Error loading models:', err);
        modelSelect.innerHTML = '<option value="">Error loading models</option>';
        summaryModelSelect.innerHTML = '<option value="">Error loading models</option>';
      }
    }
    loadModels();

    // ---------------------- PDF Drag & Drop ----------------------
    ;['dragenter', 'dragover'].forEach(ev => {
      dropArea.addEventListener(ev, e => {
        e.preventDefault();
        e.stopPropagation();
        dropArea.classList.add('dragover');
      });
    });
    ;['dragleave', 'drop'].forEach(ev => {
      dropArea.addEventListener(ev, e => {
        e.preventDefault();
        e.stopPropagation();
        dropArea.classList.remove('dragover');
      });
    });
    dropArea.addEventListener('drop', e => {
      if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return;
      const file = e.dataTransfer.files[0];
      if (!file.name.toLowerCase().endsWith('.pdf')) {
        alert('Please drop a .pdf file here');
        return;
      }
      fileInput.files = e.dataTransfer.files;
      uploadedFile = file;
      fileAttachedIndicator.textContent = `File attached: ${file.name} (${file.size} bytes)`;
    });
    // PDF file input
    fileInput.addEventListener('change', () => {
      if (fileInput.files && fileInput.files[0]) {
        const f = fileInput.files[0];
        if (!f.name.toLowerCase().endsWith('.pdf')) {
          alert('Please select a .pdf file');
          fileInput.value = '';
          return;
        }
        uploadedFile = f;
        fileAttachedIndicator.textContent = `File attached: ${f.name} (${f.size} bytes)`;
      } else {
        fileAttachedIndicator.textContent = 'No file attached yet.';
      }
    });

    // ---------------------- doc.json Drag & Drop ----------------------
    ;['dragenter', 'dragover'].forEach(ev => {
      docJsonDropArea.addEventListener(ev, e => {
        e.preventDefault();
        e.stopPropagation();
        docJsonDropArea.classList.add('dragover');
      });
    });
    ;['dragleave', 'drop'].forEach(ev => {
      docJsonDropArea.addEventListener(ev, e => {
        e.preventDefault();
        e.stopPropagation();
        docJsonDropArea.classList.remove('dragover');
      });
    });
    docJsonDropArea.addEventListener('drop', e => {
      if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return;
      const file = e.dataTransfer.files[0];
      if (!file.name.toLowerCase().endsWith('.doc.json')) {
        alert('Please drop a file ending with .doc.json');
        return;
      }
      docJsonFileInput.files = e.dataTransfer.files;
      docJsonFile = file;
      docJsonAttachedIndicator.textContent = `Doc JSON: ${file.name} (${file.size} bytes)`;
      loadDocJsonFile(file);
    });
    // docJson file input
    docJsonFileInput.addEventListener('change', () => {
      if (docJsonFileInput.files && docJsonFileInput.files[0]) {
        const f = docJsonFileInput.files[0];
        if (!f.name.toLowerCase().endsWith('.doc.json')) {
          alert('Please select a file ending with .doc.json');
          docJsonFileInput.value = '';
          return;
        }
        docJsonFile = f;
        docJsonAttachedIndicator.textContent = `Doc JSON: ${f.name} (${f.size} bytes)`;
        loadDocJsonFile(f);
      } else {
        docJsonAttachedIndicator.textContent = 'No .doc.json loaded.';
      }
    });
    async function loadDocJsonFile(file) {
      try {
        const text = await file.text();
        const docObj = JSON.parse(text);
        loadedDoc = docObj;
        // Show in #resultContainer
        resultContainer.style.display = 'block';
        jsonOutput.textContent = JSON.stringify(loadedDoc, null, 2);
        // Summaries UI
        summariesContainer.style.display = 'block';
        summaryProgressBox.style.display = 'none';
        // Chunk Group UI
        chunkGroupContainer.style.display = 'block';
        chunkGroupProgressBox.style.display = 'none';
        // JS Playground
        jsPlaygroundContainer.style.display = 'block';
      } catch (err) {
        alert('Failed to parse that .doc.json file as valid JSON.');
        console.error('Error loading doc.json:', err);
      }
    }

    // ---------------------- Convert PDF -> doc ----------------------
    convertBtn.addEventListener('click', async () => {
      if (!uploadedFile) {
        alert('Please select or drop a PDF first (or load a .doc.json).');
        return;
      }
      // Hide old results
      resultContainer.style.display = 'none';
      jsonOutput.textContent = '';
      loadedDoc = null;

      const formData = new FormData();
      formData.append('file', uploadedFile);
      formData.append('model', modelSelect.value);
      formData.append('ocr_threshold', ocrThresholdInput.value);
      formData.append('page_numbering', pageNumberingSelect.value);
      formData.append('detect_document_boundaries', detectBoundariesSelect.value);
      formData.append('describe', describeSelect.value);

      if (tagsInput.value.trim()) {
        formData.append('tags', tagsInput.value.trim());
      }
      if (descriptionInput.value.trim()) {
        formData.append('description', descriptionInput.value.trim());
      }
      if (intentInput.value.trim()) {
        formData.append('intent', intentInput.value.trim());
      }
      if (graphicInstructionsInput.value.trim()) {
        formData.append('graphic_instructions', graphicInstructionsInput.value.trim());
      }

      progressBox.style.display = 'block';
      progressStatus.textContent = 'Starting conversion job...';

      try {
        const response = await fetch(CONVERSION_BASE, {
          method: 'POST',
          body: formData
        });
        const data = await response.json();
        if (!response.ok) {
          progressStatus.textContent = `Error: ${data.error || 'Failed to start job.'}`;
          return;
        }
        const jobId = data.job_id;
        progressStatus.textContent = `Job started (job_id=${jobId}). Polling for progress...`;
        pollJobStatus(jobId);
      } catch (err) {
        console.error('Error starting doc conversion:', err);
        progressStatus.textContent = `Error: ${err.message}`;
      }
    });

    async function pollJobStatus(jobId) {
      let keepPolling = true;
      while (keepPolling) {
        await new Promise(r => setTimeout(r, 2000));
        try {
          const statusRes = await fetch(`${CHARMONIZER_BASE}/conversions/documents/${jobId}`);
          if (statusRes.status === 404) {
            progressStatus.textContent = 'Job not found (404).';
            keepPolling = false;
            return;
          }
          const statusData = await statusRes.json();
          const { status, error, pages_total, pages_converted } = statusData;
          if (status === 'pending') {
            progressStatus.textContent = `Status: pending...`;
          } else if (status === 'processing') {
            progressStatus.textContent = `Status: processing... ${pages_converted} / ${pages_total} pages.`;
          } else if (status === 'complete') {
            progressStatus.textContent = `Status: complete. Retrieving final doc...`;
            keepPolling = false;
            await retrieveDocResult(jobId);
          } else if (status === 'error') {
            progressStatus.textContent = `Error: ${error}\nConverted: ${pages_converted}/${pages_total}`;
            keepPolling = false;
          } else {
            progressStatus.textContent = `Unrecognized status: ${status}`;
            keepPolling = false;
          }
        } catch (err) {
          progressStatus.textContent = `Polling error: ${err.message}`;
          keepPolling = false;
        }
      }
    }
    async function retrieveDocResult(jobId) {
      try {
        const res = await fetch(`${CHARMONIZER_BASE}/conversions/documents/${jobId}/result`);
        if (res.status === 202) {
          progressStatus.textContent = `202: Still processing, will poll again...`;
          pollJobStatus(jobId);
          return;
        }
        if (!res.ok) {
          const errData = await res.json();
          progressStatus.textContent = `Error retrieving doc: ${errData.error}`;
          return;
        }
        const docObj = await res.json();
        loadedDoc = docObj;
        progressStatus.textContent = 'Conversion complete. Document object is ready.';
        resultContainer.style.display = 'block';
        jsonOutput.textContent = JSON.stringify(docObj, null, 2);

        // Summaries
        summariesContainer.style.display = 'block';
        summaryProgressBox.style.display = 'none';

        // Chunk Group creation
        chunkGroupContainer.style.display = 'block';
        chunkGroupProgressBox.style.display = 'none';

        // JS Playground
        jsPlaygroundContainer.style.display = 'block';

        copyJsonBtn.onclick = () => {
          navigator.clipboard.writeText(JSON.stringify(docObj, null, 2))
            .then(() => alert('JSON copied!'))
            .catch(e => console.error(e));
        };
        copyMarkdownBtn.onclick = () => {
          const fullMd = docObj.content || '(No docObj.content found)';
          navigator.clipboard.writeText(fullMd)
            .then(() => alert('Markdown copied!'))
            .catch(e => console.error(e));
        };
      } catch (err) {
        progressStatus.textContent = `Error retrieving final doc: ${err.message}`;
      }
    }

    // ---------------- Summaries Flow ----------------
    summarizeBtn.addEventListener('click', async () => {
      if (!loadedDoc) {
        alert('No doc object is loaded. Convert a PDF or load a .doc.json first.');
        return;
      }
      summaryProgressBox.style.display = 'block';
      summaryProgressStatus.textContent = 'Starting summarization...';

      const method = summaryMethodSelect.value;
      const chunk_group = chunkGroupInput.value.trim();
      const context_chunks_before = parseInt(contextBeforeInput.value, 10) || 0;
      const context_chunks_after = parseInt(contextAfterInput.value, 10) || 0;
      const guidance = summaryGuidanceInput.value.trim();
      const schemaRaw = summaryJsonSchemaInput.value.trim();
      let json_schema = null;
      if (schemaRaw) {
        try {
          json_schema = JSON.parse(schemaRaw);
        } catch (e) {
          alert('JSON Schema parse error. Summaries will proceed without schema enforcement.');
        }
      }
      const sumModel = summaryModelSelect.value.trim() || modelSelect.value;
      const temperature = 0.7;
      const json_sum = deltaFoldMergeModeSelect.value.trim();
      let initial_summary = null;
      const initSumRaw = initialSummaryInput.value.trim();
      if (initSumRaw) {
        try {
          initial_summary = JSON.parse(initSumRaw);
        } catch {
          initial_summary = initSumRaw; // fallback if not valid JSON
        }
      }

      // read annotation fields
      const annotation_field = annotationFieldInput.value.trim() || 'summary';
      const annotation_field_delta = annotationFieldDeltaInput.value.trim() || 'summary_delta';

      const body = {
        document: loadedDoc,
        model: sumModel,
        method,
        chunk_group,
        context_chunks_before,
        context_chunks_after,
        guidance,
        temperature,
        json_schema,
        json_sum,
        initial_summary,
        annotation_field,
        annotation_field_delta
      };

      // If method=map-merge, include merge_summaries_guidance
      if (method === 'map-merge') {
        const mg = mergeSummariesGuidanceInput.value.trim();
        if (mg) {
          body.merge_summaries_guidance = mg;
        }
      }

      try {
        const startRes = await fetch(SUMMARIES_BASE, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(body)
        });
        const startData = await startRes.json();
        if (!startRes.ok) {
          summaryProgressStatus.textContent = `Error: ${startData.error || 'Start summarization failed'}`;
          return;
        }
        const jobId = startData.job_id;
        summaryProgressStatus.textContent = `Summaries job started (job_id=${jobId}). Polling...`;
        pollSummariesJob(jobId);
      } catch (err) {
        summaryProgressStatus.textContent = `Error starting summarization: ${err.message}`;
      }
    });
    async function pollSummariesJob(jobId) {
      let keepPolling = true;
      while (keepPolling) {
        await new Promise(r => setTimeout(r, 2000));
        try {
          const stRes = await fetch(`${SUMMARIES_BASE}/${jobId}`);
          if (stRes.status === 404) {
            summaryProgressStatus.textContent = 'Summaries job not found.';
            return;
          }
          const stData = await stRes.json();
          const { status, chunks_total, chunks_completed, error } = stData;
          if (status === 'pending' || status === 'processing') {
            summaryProgressStatus.textContent = `Summaries: ${status} - ${chunks_completed}/${chunks_total} done.`;
          } else if (status === 'error') {
            summaryProgressStatus.textContent = `Summaries job error: ${error}`;
            keepPolling = false;
          } else if (status === 'complete') {
            summaryProgressStatus.textContent = 'Summaries complete. Fetching result.';
            keepPolling = false;
            fetchSummariesResult(jobId);
          } else {
            summaryProgressStatus.textContent = `Unknown status: ${status}`;
            keepPolling = false;
          }
        } catch (err) {
          summaryProgressStatus.textContent = `Poll error: ${err.message}`;
          keepPolling = false;
        }
      }
    }
    async function fetchSummariesResult(jobId) {
      try {
        const res = await fetch(`${SUMMARIES_BASE}/${jobId}/result`);
        if (res.status === 202) {
          summaryProgressStatus.textContent = 'Still processing... will poll again.';
          pollSummariesJob(jobId);
          return;
        }
        if (res.status === 500) {
          const errData = await res.json();
          summaryProgressStatus.textContent = `Summaries error: ${errData.error}`;
          return;
        }
        if (!res.ok) {
          const eText = await res.text();
          summaryProgressStatus.textContent = `HTTP ${res.status} - ${eText}`;
          return;
        }
        const finalDoc = await res.json();
        loadedDoc = finalDoc;
        summaryProgressStatus.textContent = 'Summaries done. Document updated.';
        jsonOutput.textContent = JSON.stringify(loadedDoc, null, 2);
      } catch (err) {
        summaryProgressStatus.textContent = `Error fetching summary result: ${err.message}`;
      }
    }

    // ---------------- Chunk Group Creation (merge_and_split) ----------------
    createChunkGroupBtn.addEventListener('click', async () => {
      if (!loadedDoc) {
        alert('No doc object is loaded. Convert a PDF or load a .doc.json first.');
        return;
      }
      chunkGroupProgressBox.style.display = 'block';
      chunkGroupProgressStatus.textContent = 'Starting chunk group creation...';

      const strategy = chunkGroupStrategySelect.value;
      const sourceGroup = sourceChunkGroupInput.value.trim();
      const size = parseInt(chunkSizeInput.value, 10) || 1000;
      const newName = newChunkGroupNameInput.value.trim() || 'mergedPages';

      const body = {
        document: loadedDoc,
        strategy,
        chunk_size: size,
        chunk_group: sourceGroup
      };

      try {
        const startRes = await fetch(CHUNKINGS_BASE, {
          method: 'POST',
          headers: {'Content-Type':'application/json'},
          body: JSON.stringify(body)
        });
        const startData = await startRes.json();
        if (!startRes.ok) {
          chunkGroupProgressStatus.textContent = `Error: ${startData.error || 'Failed to start chunking job'}`;
          return;
        }
        const jobId = startData.job_id;
        chunkGroupProgressStatus.textContent = `Chunking job started (job_id=${jobId}). Polling...`;
        pollChunkingJob(jobId, newName);
      } catch (err) {
        chunkGroupProgressStatus.textContent = `Error starting chunking: ${err.message}`;
      }
    });

    async function pollChunkingJob(jobId, newGroupName) {
      let keepPolling = true;
      while (keepPolling) {
        await new Promise(r => setTimeout(r, 2000));
        try {
          const stRes = await fetch(`${CHUNKINGS_BASE}/${jobId}`);
          if (stRes.status === 404) {
            chunkGroupProgressStatus.textContent = 'Chunking job not found.';
            return;
          }
          const stData = await stRes.json();
          const { status, progress, error } = stData;
          if (status === 'pending' || status === 'in_progress') {
            chunkGroupProgressStatus.textContent = `Chunking: ${status} - ${progress || 0}% done.`;
          } else if (status === 'error') {
            chunkGroupProgressStatus.textContent = `Chunking job error: ${error}`;
            keepPolling = false;
          } else if (status === 'complete') {
            chunkGroupProgressStatus.textContent = 'Chunking complete. Fetching result.';
            keepPolling = false;
            fetchChunkingResult(jobId, newGroupName);
          } else {
            chunkGroupProgressStatus.textContent = `Unknown status: ${status}`;
            keepPolling = false;
          }
        } catch (err) {
          chunkGroupProgressStatus.textContent = `Poll error: ${err.message}`;
          keepPolling = false;
        }
      }
    }

    async function fetchChunkingResult(jobId, newGroupName) {
      try {
        const res = await fetch(`${CHUNKINGS_BASE}/${jobId}/result`);
        if (res.status === 409) {
          const errData = await res.json();
          chunkGroupProgressStatus.textContent = `Conflict or error: ${errData.error || 'Job not complete yet'}`;
          return;
        }
        if (!res.ok) {
          const eText = await res.text();
          chunkGroupProgressStatus.textContent = `HTTP ${res.status} - ${eText}`;
          return;
        }
        const finalData = await res.json(); // { job_id, chunks: [...] }
        chunkGroupProgressStatus.textContent = 'Chunking result retrieved. Incorporating into doc...';

        // finalData.chunks is an array of {chunk_index, chunk_data:{title, body}}.
        // We'll build a new chunk array of doc objects under loadedDoc.chunks[newGroupName].
        if (!loadedDoc.chunks) {
          loadedDoc.chunks = {};
        }
        loadedDoc.chunks[newGroupName] = finalData.chunks.map((c) => {
          const idx = c.chunk_index; // 1-based
          const docChunk = {
            id: `${loadedDoc.id}/${newGroupName}@${idx - 1}`,
            parent: loadedDoc.id,
            content: c.chunk_data.body || '',
            metadata: {
              original_title: c.chunk_data.title || ''
            }
          };
          return docChunk;
        });

        // Now update the display
        chunkGroupProgressStatus.textContent = `New chunk group "${newGroupName}" created with ${finalData.chunks.length} chunks.`;
        jsonOutput.textContent = JSON.stringify(loadedDoc, null, 2);
      } catch (err) {
        chunkGroupProgressStatus.textContent = `Error fetching chunking result: ${err.message}`;
      }
    }


    // ---------------- JavaScript Playground ----------------
    const codeTemplates = {
      extractSummary: `function run(docObj) {
  // docObj is the JSON Document object
  // We'll just return the top-level summary as Markdown
  const summary = docObj.annotations?.summary;
  if (!summary) {
    return "No top-level summary found.";
  }
  // If it's structured, you may want to do something else,
  // but let's just convert it to a string
  const text = (typeof summary === 'string')
    ? summary
    : JSON.stringify(summary, null, 2);

  return "## High-level summary\\n\\n" + text;
}
`,
      extractChunkSummaries: `function run(docObj) {
  // We'll gather summaries from each page in docObj.chunks.pages
  if (!docObj.chunks?.pages) {
    return "No pages found in docObj.chunks.pages.";
  }
  let output = "# Summaries from all chunks\\n\\n";
  docObj.chunks.pages.forEach((page, idx) => {
    const sum = page.annotations?.summary;
    if (!sum) {
      output += "### Page " + (idx+1) + ": No summary found\\n\\n";
    } else {
      // If sum is an object, convert to string
      const sumText = (typeof sum === 'string')
        ? sum
        : JSON.stringify(sum, null, 2);
      output += "### Page " + (idx+1) + " Summary\\n\\n" + sumText + "\\n\\n";
    }
  });
  return output;
}
`
    };

    loadTemplateBtn.addEventListener('click', () => {
      const choice = jsSnippetSelect.value;
      if (!choice || !codeTemplates[choice]) {
        alert('Please select a valid template.');
        return;
      }
      userCodeArea.value = codeTemplates[choice];
    });

    runJsBtn.addEventListener('click', () => {
      if (!loadedDoc) {
        alert('No doc is loaded to run code against. Please load or convert a doc first.');
        return;
      }
      const userJs = userCodeArea.value;
      jsPlaygroundOutput.innerHTML = '<em>Running...</em>';

      let runFn;
      try {
        runFn = new Function('docObj', userJs + '\n\nreturn run(docObj);');
      } catch (err) {
        jsPlaygroundOutput.innerHTML = `<span style="color:red;">Error creating function: ${err.message}</span>`;
        return;
      }

      let result;
      try {
        result = runFn(loadedDoc);
      } catch (err) {
        jsPlaygroundOutput.innerHTML = `<span style="color:red;">Runtime error: ${err.message}</span>`;
        return;
      }

      if (typeof result !== 'string') {
        jsPlaygroundOutput.innerHTML = `<span style="color:red;">Your run() did not return a string. Instead got type: ${typeof result}</span>`;
        return;
      }

      const sanitizedMd = DOMPurify.sanitize(marked.parse(result));
      jsPlaygroundOutput.innerHTML = sanitizedMd;
    });

  })();
</script>

</body>
</html>
