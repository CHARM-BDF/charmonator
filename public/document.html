<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Document Conversion Playground</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- Link to the main stylesheet -->
  <link rel="stylesheet" href="styles.css">

  <!-- Font Awesome for copy icons (optional) -->
  <link 
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  />

  <style>
    /* Container for the entire page */
    .page-container {
      display: flex;
      flex-direction: column;
      max-width: 1100px;
      margin: 0 auto;
      padding: 20px;
      background-color: #fff;
      border-radius: 10px;
    }
    /* Header style */
    .header {
      margin-bottom: 20px;
    }
    /* Form container for options and file upload */
    .options-form {
      display: flex;
      flex-wrap: wrap;
      gap: 20px;
      border: 1px solid #eee;
      padding: 20px;
      border-radius: 10px;
    }
    /* Each option item style */
    .option-item {
      display: flex;
      flex-direction: column;
      width: 220px;
    }
    .option-item label {
      font-weight: 600;
      margin-bottom: 5px;
    }
    .option-item input,
    .option-item select,
    .option-item textarea {
      padding: 6px 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
      font-size: 14px;
    }
    .option-item textarea {
      resize: vertical;
    }
    /* Container for the Convert button */
    .convert-button-container {
      margin-top: 20px;
      text-align: center;
    }
    .convert-button {
      padding: 10px 25px;
      font-size: 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      background-color: #d0f0c0;
    }
    .convert-button:hover {
      background-color: #b0e0a0;
    }
    /* Progress box style */
    .progress-box {
      margin-top: 20px;
      padding: 15px;
      border: 1px solid #eaeaea;
      border-radius: 8px;
      background-color: #f9f9f9;
    }
    /* Final result container style */
    .result-container {
      margin-top: 20px;
      display: none; /* hidden until result is ready */
    }
    .json-result {
      width: 100%;
      height: 300px;
      overflow: auto;
      background-color: #fafafa;
      border: 1px solid #ccc;
      padding: 10px;
      border-radius: 4px;
      white-space: pre;
      font-family: monospace;
    }
    .result-buttons {
      margin-top: 10px;
      display: flex;
      gap: 10px;
    }
    /* Indicator for attached file */
    #fileAttachedIndicator {
      margin-top: 5px;
      font-size: 14px;
      color: #666;
    }
  </style>
</head>
<body>

<div class="page-container">

  <!-- Main page title -->
  <h1 class="header">Document Conversion Playground</h1>

  <!-- Options and file upload form -->
  <div class="options-form">

    <!-- Model selection drop-down -->
    <div class="option-item">
      <label for="modelSelect">Model</label>
      <select id="modelSelect">
        <option value="">Loading models...</option>
      </select>
    </div>

    <!-- Minimum OCR quality field -->
    <div class="option-item">
      <label for="ocrThresholdInput">Minimum OCR quality</label>
      <input type="number" id="ocrThresholdInput" min="0" max="1" step="0.05" value="1.0">
    </div>

    <!-- Page numbering option -->
    <div class="option-item">
      <label for="pageNumberingSelect">Page Numbering</label>
      <select id="pageNumberingSelect">
        <option value="true" selected>Enable</option>
        <option value="false">Disable</option>
      </select>
    </div>

    <!-- Detect boundaries option -->
    <div class="option-item">
      <label for="detectBoundariesSelect">Detect Boundaries</label>
      <select id="detectBoundariesSelect">
        <option value="false" selected>No</option>
        <option value="true">Yes</option>
      </select>
    </div>

    <!-- Generate description option -->
    <div class="option-item">
      <label for="describeSelect">Generate description?</label>
      <select id="describeSelect">
        <option value="true" selected>Yes</option>
        <option value="false">No</option>
      </select>
    </div>

    <!-- Generate tags? (JSON) field with example -->
    <div class="option-item">
      <label for="tagsInput">Generate tags? (JSON)</label>
      <textarea id="tagsInput" rows="3" placeholder='{"pricing": "info on pricing", "genetics": "info relevant to genetics"}'></textarea>
    </div>

    <!-- Page description field -->
    <div class="option-item">
      <label for="descriptionInput">Page Description</label>
      <textarea id="descriptionInput" rows="3" placeholder="High-level doc description"></textarea>
    </div>

    <!-- Intent field -->
    <div class="option-item">
      <label for="intentInput">Intent</label>
      <textarea id="intentInput" rows="3" placeholder="What do you plan to do with the doc?"></textarea>
    </div>

    <!-- Graphic instructions field -->
    <div class="option-item">
      <label for="graphicInstructionsInput">Graphic Inst.</label>
      <textarea id="graphicInstructionsInput" rows="3" placeholder="Extra instructions for charts/figures"></textarea>
    </div>

    <!-- File upload area (PDF) -->
    <div style="width: 100%; margin-top:10px;">
      <label style="font-weight:600; display:block; margin-bottom:5px;">File to convert (.pdf)</label>
      <div id="dropArea" class="drop-area">
        <label for="fileInput" id="fileInputLabel">Attach PDF</label>
        <input type="file" id="fileInput" accept=".pdf" />
      </div>
      <!-- Visible indicator that shows when a PDF is attached -->
      <p id="fileAttachedIndicator">No file attached yet.</p>
    </div>

    <!-- Another area for .doc.json files -->
    <div style="width: 100%; margin-top:10px;">
      <label style="font-weight:600; display:block; margin-bottom:5px;">Or load existing .doc.json</label>
      <div id="docJsonDropArea" class="drop-area">
        <label for="docJsonFileInput" id="docJsonFileLabel">Attach .doc.json</label>
        <input type="file" id="docJsonFileInput" accept=".doc.json" />
      </div>
      <p id="docJsonAttachedIndicator">No .doc.json loaded.</p>
    </div>

  </div> <!-- .options-form -->

  <!-- Convert Document button -->
  <div class="convert-button-container">
    <button class="convert-button" id="convertBtn">Convert Document</button>
  </div>

  <!-- Progress box -->
  <div class="progress-box" id="progressBox" style="display: none;">
    <div id="progressStatus"></div>
  </div>

  <!-- Final result display -->
  <div class="result-container" id="resultContainer">
    <h2>Conversion Result (JSON Document Object)</h2>
    <div class="json-result" id="jsonOutput"></div>
    <div class="result-buttons">
      <button id="copyJsonBtn"><i class="fa fa-copy"></i> Copy JSON</button>
      <button id="copyMarkdownBtn"><i class="fa fa-copy"></i> Copy as Markdown</button>
    </div>
  </div>

  <!-- Summaries container (hidden by default) -->
  <div class="result-container" id="summariesContainer" style="display: none;">
    <h2>Summaries</h2>
    <div style="display:flex; flex-wrap:wrap; gap:20px; border:1px solid #eee; padding:20px; border-radius:10px;">

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryMethodSelect"><b>Method</b></label>
        <select id="summaryMethodSelect">
          <option value="full">full</option>
          <option value="map">map</option>
          <option value="fold">fold</option>
          <option value="delta-fold">delta-fold</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="chunkGroupInput"><b>Chunk Group</b></label>
        <input type="text" id="chunkGroupInput" value="pages">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="contextBeforeInput"><b>Context Chunks (Before)</b></label>
        <input type="number" id="contextBeforeInput" min="0" value="0">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="contextAfterInput"><b>Context Chunks (After)</b></label>
        <input type="number" id="contextAfterInput" min="0" value="0">
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryGuidanceInput"><b>Guidance</b></label>
        <textarea id="summaryGuidanceInput" rows="3" placeholder="Any extra instructions..."></textarea>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryJsonSchemaInput"><b>JSON Schema (optional)</b></label>
        <textarea id="summaryJsonSchemaInput" rows="3" placeholder='{"type":"object","properties":{...}}'></textarea>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="summaryModelSelect"><b>Summary Model</b></label>
        <select id="summaryModelSelect">
          <option value="">Use same model as above</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="deltaFoldMergeModeSelect"><b>delta-fold Merge Mode</b></label>
        <select id="deltaFoldMergeModeSelect">
          <option value="append" selected>append</option>
          <option value="push">push (array push)</option>
        </select>
      </div>

      <div style="display:flex; flex-direction:column; width:220px;">
        <label for="initialSummaryInput"><b>Initial Summary (fold/delta-fold)</b></label>
        <textarea id="initialSummaryInput" rows="3" placeholder="Optional existing summary or array"></textarea>
      </div>

    </div>

    <div style="text-align:center; margin-top:20px;">
      <button class="convert-button" id="summarizeBtn">Summarize</button>
    </div>

    <div class="progress-box" id="summaryProgressBox" style="display:none;">
      <div id="summaryProgressStatus"></div>
    </div>

  </div>
</div> <!-- .page-container -->

<script>
  (function(){
    // Base endpoint constants
    const CONVERSION_BASE = 'api/charmonizer/v1';
    const MODELS_ENDPOINT = 'api/charmonator/v1/models';
    const SUMMARIES_BASE = 'api/charmonizer/v1/summaries';

    // DOM references
    const fileInput = document.getElementById('fileInput');
    const dropArea = document.getElementById('dropArea');
    const fileAttachedIndicator = document.getElementById('fileAttachedIndicator');

    const modelSelect = document.getElementById('modelSelect');
    const ocrThresholdInput = document.getElementById('ocrThresholdInput');
    const pageNumberingSelect = document.getElementById('pageNumberingSelect');
    const detectBoundariesSelect = document.getElementById('detectBoundariesSelect');
    const describeSelect = document.getElementById('describeSelect');
    const tagsInput = document.getElementById('tagsInput');
    const descriptionInput = document.getElementById('descriptionInput');
    const intentInput = document.getElementById('intentInput');
    const graphicInstructionsInput = document.getElementById('graphicInstructionsInput');
    const convertBtn = document.getElementById('convertBtn');
    const progressBox = document.getElementById('progressBox');
    const progressStatus = document.getElementById('progressStatus');
    const resultContainer = document.getElementById('resultContainer');
    const jsonOutput = document.getElementById('jsonOutput');
    const copyJsonBtn = document.getElementById('copyJsonBtn');
    const copyMarkdownBtn = document.getElementById('copyMarkdownBtn');

    // For .doc.json
    const docJsonFileInput = document.getElementById('docJsonFileInput');
    const docJsonDropArea = document.getElementById('docJsonDropArea');
    const docJsonAttachedIndicator = document.getElementById('docJsonAttachedIndicator');

    // Summaries UI
    const summariesContainer = document.getElementById('summariesContainer');
    const summarizeBtn = document.getElementById('summarizeBtn');
    const summaryProgressBox = document.getElementById('summaryProgressBox');
    const summaryProgressStatus = document.getElementById('summaryProgressStatus');

    const summaryMethodSelect = document.getElementById('summaryMethodSelect');
    const chunkGroupInput = document.getElementById('chunkGroupInput');
    const contextBeforeInput = document.getElementById('contextBeforeInput');
    const contextAfterInput = document.getElementById('contextAfterInput');
    const summaryGuidanceInput = document.getElementById('summaryGuidanceInput');
    const summaryJsonSchemaInput = document.getElementById('summaryJsonSchemaInput');
    const summaryModelSelect = document.getElementById('summaryModelSelect');
    const deltaFoldMergeModeSelect = document.getElementById('deltaFoldMergeModeSelect');
    const initialSummaryInput = document.getElementById('initialSummaryInput');

    let uploadedFile = null;    // for PDF
    let docJsonFile = null;     // for .doc.json
    let loadedDoc = null;       // store the final loaded doc object

    console.log("[document.html] Script loaded.");

    // ---------------------- Load Models into Drop-down ----------------------
    async function loadModels() {
      try {
        const response = await fetch(MODELS_ENDPOINT);
        if (!response.ok) {
          throw new Error('Failed to fetch models');
        }
        const data = await response.json();
        // Clear any existing options
        modelSelect.innerHTML = '';
        summaryModelSelect.innerHTML = '<option value="">Use same model as above</option>';

        data.models.forEach(model => {
          const option = document.createElement('option');
          option.value = model.id;
          option.textContent = model.name;
          option.title = model.description;
          modelSelect.appendChild(option);

          // also add to summaryModelSelect
          const smOption = document.createElement('option');
          smOption.value = model.id;
          smOption.textContent = model.name;
          smOption.title = model.description;
          summaryModelSelect.appendChild(smOption);
        });
      } catch (err) {
        console.error("[doc.html] Error loading models:", err);
        modelSelect.innerHTML = '<option value="">Error loading models</option>';
        summaryModelSelect.innerHTML = '<option value="">Error loading models</option>';
      }
    }
    loadModels();


    // ---------------------- PDF Drag & Drop Setup ----------------------
    ['dragenter', 'dragover'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropArea.classList.add('dragover');
      });
    });
    ['dragleave', 'drop'].forEach(eventName => {
      dropArea.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        dropArea.classList.remove('dragover');
      });
    });
    dropArea.addEventListener('drop', (e) => {
      if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) {
        return;
      }
      const file = e.dataTransfer.files[0];
      if (!file) return;
      // We only handle .pdf here
      if (!file.name.toLowerCase().endsWith('.pdf')) {
        alert('Please drop a .pdf file here');
        return;
      }
      fileInput.files = e.dataTransfer.files;
      uploadedFile = file;
      fileAttachedIndicator.textContent = `File attached: ${file.name} (${file.size} bytes)`;
    });

    // ---------------------- PDF File Input (click-based) ----------------------
    fileInput.addEventListener('change', () => {
      if (fileInput.files && fileInput.files[0]) {
        const f = fileInput.files[0];
        if (!f.name.toLowerCase().endsWith('.pdf')) {
          alert('Please select a .pdf file');
          fileInput.value = '';
          return;
        }
        uploadedFile = f;
        fileAttachedIndicator.textContent = `File attached: ${f.name} (${f.size} bytes)`;
      } else {
        fileAttachedIndicator.textContent = 'No file attached yet.';
      }
    });


    // ---------------------- .doc.json drag & drop ----------------------
    ['dragenter', 'dragover'].forEach(eventName => {
      docJsonDropArea.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        docJsonDropArea.classList.add('dragover');
      });
    });
    ['dragleave', 'drop'].forEach(eventName => {
      docJsonDropArea.addEventListener(eventName, (e) => {
        e.preventDefault();
        e.stopPropagation();
        docJsonDropArea.classList.remove('dragover');
      });
    });
    docJsonDropArea.addEventListener('drop', (e) => {
      if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return;
      const file = e.dataTransfer.files[0];
      if (!file) return;
      if (!file.name.toLowerCase().endsWith('.doc.json')) {
        alert('Please drop a file ending with .doc.json');
        return;
      }
      docJsonFileInput.files = e.dataTransfer.files;
      docJsonFile = file;
      docJsonAttachedIndicator.textContent = `Doc JSON: ${file.name} (${file.size} bytes)`;
      loadDocJsonFile(file);
    });

    docJsonFileInput.addEventListener('change', () => {
      if (docJsonFileInput.files && docJsonFileInput.files[0]) {
        const f = docJsonFileInput.files[0];
        if (!f.name.toLowerCase().endsWith('.doc.json')) {
          alert('Please select a file ending with .doc.json');
          docJsonFileInput.value = '';
          return;
        }
        docJsonFile = f;
        docJsonAttachedIndicator.textContent = `Doc JSON: ${f.name} (${f.size} bytes)`;
        loadDocJsonFile(f);
      } else {
        docJsonAttachedIndicator.textContent = 'No .doc.json loaded.';
      }
    });

    async function loadDocJsonFile(file) {
      try {
        const text = await file.text();
        const docObj = JSON.parse(text);
        loadedDoc = docObj;
        // Show in #resultContainer
        resultContainer.style.display = 'block';
        jsonOutput.textContent = JSON.stringify(loadedDoc, null, 2);
        // Show the Summaries UI
        summariesContainer.style.display = 'block';
        summaryProgressBox.style.display = 'none';
      } catch (err) {
        console.error('Error loading doc.json:', err);
        alert('Failed to parse that .doc.json file as valid JSON.');
      }
    }


    // ---------------------- Convert Button (PDF -> doc) ----------------------
    convertBtn.addEventListener('click', async () => {
      if (!uploadedFile) {
        alert('Please select or drop a PDF file first (or load a .doc.json below).');
        return;
      }
      // Hide old results
      resultContainer.style.display = 'none';
      jsonOutput.textContent = '';
      loadedDoc = null; // clear previous doc

      // Build form data
      const formData = new FormData();
      formData.append('file', uploadedFile);
      formData.append('model', modelSelect.value);
      formData.append('ocr_threshold', ocrThresholdInput.value);
      formData.append('page_numbering', pageNumberingSelect.value);
      formData.append('detect_document_boundaries', detectBoundariesSelect.value);
      formData.append('describe', describeSelect.value);

      if (tagsInput.value.trim()) {
        formData.append('tags', tagsInput.value.trim());
      }
      if (descriptionInput.value.trim()) {
        formData.append('description', descriptionInput.value.trim());
      }
      if (intentInput.value.trim()) {
        formData.append('intent', intentInput.value.trim());
      }
      if (graphicInstructionsInput.value.trim()) {
        formData.append('graphic_instructions', graphicInstructionsInput.value.trim());
      }

      progressBox.style.display = 'block';
      progressStatus.textContent = 'Starting conversion job...';

      try {
        const response = await fetch(`${CONVERSION_BASE}/conversions/documents`, {
          method: 'POST',
          body: formData
        });
        const data = await response.json();
        if (!response.ok) {
          progressStatus.textContent = `Error: ${data.error || 'Failed to start conversion job.'}`;
          return;
        }
        const jobId = data.job_id;
        progressStatus.textContent = `Job started (job_id=${jobId}). Polling for progress...`;
        pollJobStatus(jobId);
      } catch (err) {
        console.error('Error starting doc conversion:', err);
        progressStatus.textContent = `Error: ${err.message}`;
      }
    });

    async function pollJobStatus(jobId) {
      let keepPolling = true;
      while (keepPolling) {
        await new Promise(r => setTimeout(r, 2000));
        try {
          const statusRes = await fetch(`${CONVERSION_BASE}/conversions/documents/${jobId}`);
          if (statusRes.status === 404) {
            progressStatus.textContent = 'Job not found (404).';
            keepPolling = false;
            return;
          }
          const statusData = await statusRes.json();
          const { status, error, pages_total, pages_converted } = statusData;
          if (status === 'pending') {
            progressStatus.textContent = `Status: pending...`;
          } else if (status === 'processing') {
            progressStatus.textContent = `Status: processing... ${pages_converted} / ${pages_total} pages.`;
          } else if (status === 'complete') {
            progressStatus.textContent = `Status: complete. Retrieving final document...`;
            keepPolling = false;
            await retrieveDocResult(jobId);
          } else if (status === 'error') {
            progressStatus.textContent = `Error: ${error}\nConverted: ${pages_converted}/${pages_total}`;
            keepPolling = false;
          } else {
            progressStatus.textContent = `Status: ${status}. (Unrecognized)`;
            keepPolling = false;
          }
        } catch (err) {
          progressStatus.textContent = `Polling error: ${err.message}`;
          keepPolling = false;
        }
      }
    }

    async function retrieveDocResult(jobId) {
      try {
        const res = await fetch(`${CONVERSION_BASE}/conversions/documents/${jobId}/result`);
        if (res.status === 202) {
          progressStatus.textContent = `Still processing (202). Will poll again...`;
          pollJobStatus(jobId);
          return;
        }
        if (!res.ok) {
          const errData = await res.json();
          progressStatus.textContent = `Error retrieving final doc: ${errData.error}`;
          return;
        }
        const docObj = await res.json();
        loadedDoc = docObj;
        progressStatus.textContent = 'Conversion complete. Document object is ready.';
        resultContainer.style.display = 'block';
        jsonOutput.textContent = JSON.stringify(docObj, null, 2);

        // Summaries are now available
        summariesContainer.style.display = 'block';
        summaryProgressBox.style.display = 'none';

        copyJsonBtn.onclick = () => {
          navigator.clipboard.writeText(JSON.stringify(docObj, null, 2))
            .then(() => { alert('JSON copied to clipboard!'); })
            .catch(e => console.error('Copy JSON error', e));
        };
        copyMarkdownBtn.onclick = () => {
          const fullMd = docObj.content || '(No docObj.content found)';
          navigator.clipboard.writeText(fullMd)
            .then(() => { alert('Markdown content copied to clipboard!'); })
            .catch(e => console.error('Copy MD error', e));
        };
      } catch (err) {
        progressStatus.textContent = `Error retrieving final doc: ${err.message}`;
      }
    }


    // ---------------- Summarization Flow ----------------
    summarizeBtn.addEventListener('click', async () => {
      if (!loadedDoc) {
        alert('No document is loaded. Convert a PDF first or load a .doc.json file.');
        return;
      }
      // Hide old progress
      summaryProgressBox.style.display = 'block';
      summaryProgressStatus.textContent = 'Starting summarization...';

      const method = summaryMethodSelect.value;
      const chunk_group = chunkGroupInput.value.trim();
      const context_chunks_before = parseInt(contextBeforeInput.value, 10) || 0;
      const context_chunks_after = parseInt(contextAfterInput.value, 10) || 0;
      const guidance = summaryGuidanceInput.value.trim();
      const schemaRaw = summaryJsonSchemaInput.value.trim();
      let json_schema = null;
      if (schemaRaw) {
        try {
          json_schema = JSON.parse(schemaRaw);
        } catch (e) {
          alert('JSON Schema parse error. Summaries will proceed without schema enforcement.');
        }
      }
      const sumModel = summaryModelSelect.value.trim() || modelSelect.value;
      const temperature = 0.7; // fixed or you can add an input
      const json_sum = deltaFoldMergeModeSelect.value.trim();
      let initial_summary = null;
      const initSumRaw = initialSummaryInput.value.trim();
      if (initSumRaw) {
        try {
          initial_summary = JSON.parse(initSumRaw);
        } catch {
          initial_summary = initSumRaw; // if not JSON parseable
        }
      }

      // Build payload
      const body = {
        document: loadedDoc,
        model: sumModel,
        method,
        chunk_group,
        context_chunks_before,
        context_chunks_after,
        guidance,
        temperature,
        json_schema,
        json_sum,
        initial_summary
      };

      try {
        const startRes = await fetch(`${SUMMARIES_BASE}`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(body)
        });
        const startData = await startRes.json();
        if (!startRes.ok) {
          summaryProgressStatus.textContent = `Error: ${startData.error || 'Failed to start summarization'}`;
          return;
        }
        const jobId = startData.job_id;
        summaryProgressStatus.textContent = `Summaries job started (job_id=${jobId}). Polling...`;
        pollSummariesJob(jobId);
      } catch (err) {
        summaryProgressStatus.textContent = `Error starting summarization: ${err.message}`;
      }
    });

    async function pollSummariesJob(jobId) {
      let keepPolling = true;
      while (keepPolling) {
        await new Promise(r => setTimeout(r, 2000));
        try {
          const stRes = await fetch(`${SUMMARIES_BASE}/${jobId}`);
          if (stRes.status === 404) {
            summaryProgressStatus.textContent = `Job not found.`;
            return;
          }
          const stData = await stRes.json();
          const { status, chunks_total, chunks_completed, error } = stData;
          if (status === 'pending' || status === 'processing') {
            summaryProgressStatus.textContent = `Summaries: ${status} - ${chunks_completed}/${chunks_total} done.`;
          } else if (status === 'error') {
            summaryProgressStatus.textContent = `Summaries job error: ${error}`;
            keepPolling = false;
          } else if (status === 'complete') {
            summaryProgressStatus.textContent = `Summaries complete. Fetching result.`;
            keepPolling = false;
            fetchSummariesResult(jobId);
          } else {
            summaryProgressStatus.textContent = `Unknown status: ${status}`;
            keepPolling = false;
          }
        } catch (err) {
          summaryProgressStatus.textContent = `Poll error: ${err.message}`;
          keepPolling = false;
        }
      }
    }

    async function fetchSummariesResult(jobId) {
      try {
        const res = await fetch(`${SUMMARIES_BASE}/${jobId}/result`);
        if (res.status === 202) {
          summaryProgressStatus.textContent = `Still processing... will poll again.`;
          pollSummariesJob(jobId);
          return;
        }
        if (res.status === 500) {
          const errData = await res.json();
          summaryProgressStatus.textContent = `Error in summarization: ${errData.error}`;
          return;
        }
        if (!res.ok) {
          const eText = await res.text();
          summaryProgressStatus.textContent = `Error: HTTP ${res.status} - ${eText}`;
          return;
        }
        const finalDoc = await res.json();
        loadedDoc = finalDoc; // store updated doc

        summaryProgressStatus.textContent = 'Summaries done. Updated doc loaded.';
        // Show updated doc in #jsonOutput
        jsonOutput.textContent = JSON.stringify(loadedDoc, null, 2);
      } catch (err) {
        summaryProgressStatus.textContent = `Error fetching summary result: ${err.message}`;
      }
    }

  })();
</script>

</body>
</html>
